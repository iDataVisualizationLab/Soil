<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D Cores</title>
    <!--3D-->
    <script src="lib/threejs/three.js"></script>
    <script src="lib/threejs/OrbitControls.js"></script>
    <script src="lib/threejs/DragControls.js"></script>
    <script src="js/profileobject.js"></script>
    <!--Data-->
    <script src="lib/d3/d3.v6.js"></script>
    <script src="js/colorschemes.js"></script>
    <script src="js/settings.js"></script>
    <script src="js/dataprocessing.js"></script>
    <script src="lib/kriging.js"></script>
    <script src="js/canvastexture.js"></script>
    <style>
        @import "js/loader/loader.css";
    </style>

</head>
<body>
<!--loader-->
<script src="js/loader/loader.js"></script>
<script>
    showLoader();
    let camera, renderer, textureLoader;
    let theProfile, horizCutPlane;
    let orbitControls, dragControls;
    let data;
    const profileToCanvasScale = d3.scaleLinear().domain([-0.5, 0.5]).range([0, 49]);
    main();

    async function main() {
        //Setup data
        const pd = new ProfileDescription('./data/L.csv', locationNameMapping);
        const elements = await pd.getElements();
        const csvContent = await pd.getCsvContent();
        const elementScalers = await pd.getElementScalers();
        const ip = new Interpolator(csvContent, elements, depthNames, locationNameMapping, 50, 50, elementScalers);

        // const colorScale = new d3.scaleLinear().domain([0, 1]).range(['blue', 'red']);
        const colorScale = new d3.scaleLinear().domain([0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]).range(colors10);
        //Preload the data for this element
        ip.getInterpolatedData('Al Concentration');
        const hth = new HorizontalCanvasTextureHandler(ip, 'Al Concentration', colorScale);
        const vth = new VerticalCanvasTextureHandler(ip, 'Al Concentration', colorScale);

        init();

        function init() {
            textureLoader = new THREE.TextureLoader();
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 100);
            camera.position.set(0, 0, 3);

            scene = new THREE.Scene();
            scene.add(new THREE.AmbientLight(0xffffff, 1));


            //Inputs
            let horizCutY = -0.5;
            theProfile = createProfileObject(horizCutY);
            const verticalCutTexture = vth.getTexture(0);
            const horizontalCutTexture = hth.getTexture(Math.round(profileToCanvasScale(horizCutY)));
            theProfile.handleHorizCutPosition(horizCutY, horizontalCutTexture);
            theProfile.handleVertiCutAngle(0, verticalCutTexture);
            scene.add(theProfile);
            horizCutPlane = createHorizontalCutPlane(horizCutY);
            scene.add(horizCutPlane);


            renderer = new THREE.WebGLRenderer({antialias: true});
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0xffffff);

            //Add the orbit control
            orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
            orbitControls.minDistance = 1;
            orbitControls.maxDistance = 4;
            orbitControls.maxPolarAngle = Math.PI / 2;
            //
            orbitControls.minAzimuthAngle = -Math.PI / 2;
            orbitControls.maxAzimuthAngle = Math.PI / 2;

            orbitControls.addEventListener("change", function () {
                const cutAngle = orbitControls.getAzimuthalAngle();
                theProfile.handleVertiCutAngle(cutAngle, undefined);
                theProfile.rotation.y = orbitControls.getAzimuthalAngle();
            });
            // orbitControls.addEventListener("start", function () {
            //     showLoader();
            // });
            orbitControls.addEventListener("end", function () {
                const cutAngle = orbitControls.getAzimuthalAngle();
                const texture = vth.getTexture(cutAngle);
                theProfile.handleVertiCutAngle(cutAngle, texture);
                // hideLoader();
                theProfile.rotation.y = orbitControls.getAzimuthalAngle();
            });
            //Add the drag control
            addDragControls([horizCutPlane], renderer, camera, orbitControls, theProfile);
            document.body.appendChild(renderer.domElement);
            render();
            hideLoader();
        }

        function render() {
            orbitControls.update();
            renderer.render(scene, camera);
            requestAnimationFrame(render);
        }

        function addDragControls(draggableObjects, renderer, camera, orbitControls, theProfile) {
            let horizCutPlaneX, horizCutPlaneZ;

            dragControls = new THREE.DragControls(draggableObjects, camera, renderer.domElement);
            dragControls.addEventListener('hoveron', function (event) {
                event.object.material.emissive.set(0xaa0000);
            });
            dragControls.addEventListener('hoveroff', function (event) {
                event.object.material.emissive.set(0x000000);
            });
            dragControls.addEventListener("dragstart", function (event) {
                orbitControls.enabled = false;
                horizCutPlaneX = event.object.position.x;
                horizCutPlaneZ = event.object.position.z;
            });
            dragControls.addEventListener("drag", function (event) {
                event.object.position.x = horizCutPlaneX;
                event.object.position.z = horizCutPlaneZ;
                if (event.object.position.y > 0.5) {
                    event.object.position.y = 0.5;
                }
                if (event.object.position.y < -0.5) {
                    event.object.position.y = -0.5;
                }
                //TODO: may need to handle the y value to avoid creating/resetting the same texture (since the drag is continuous -0.5 to 0.5 and texture is discrete 0 to 50)
                const texture = hth.getTexture(Math.round(profileToCanvasScale(event.object.position.y)));
                theProfile.handleHorizCutPosition(event.object.position.y, texture);

            });
            dragControls.addEventListener("dragend", function (event) {
                orbitControls.enabled = true;
            });
        }
    }
</script>
</body>
</html>
