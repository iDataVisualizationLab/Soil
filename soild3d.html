<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Soil 3D</title>
    <script src="lib/d3.js"></script>
    <script src="lib/d3-color.v1.min.js"></script>
    <script src="lib/simple-statistics.min.js"></script>
    <script src="lib/kriging.js"></script>
    <script src="lib/three.js"></script>
    <script src="lib/OrbitControls.js"></script>
</head>
<body>
<div id="container1"></div>
<div id="container2"></div>
<script src="js/colorschemes.js"></script>
<script src="js/globalsettings.js"></script>
<script src="js/dataprocessing.js"></script>
<script>
    let renderer, scene, camera;
    let pointSize = 0.1;
    //Load data
    readData("data/" + "Profile1", handleData);

    function handleData(data) {
        setContourInformation();
        setContourData(0, true, 0.05);
        setContourData(1, true, 0.05);
        pointCloudData[0] = generatePointcloud(contourData[0][0]);
        pointCloudData[1] = generatePointcloud(contourData[1][0]);

        //Call the 3d part.
        init();
        animate();

        function setupScene() {
            let bgGeometry = new THREE.BoxGeometry(8, 9, 1);
            let bgMaterial = [
                new THREE.MeshStandardMaterial({
                    color: new THREE.Color(1, 1, 1)
                }),

                new THREE.MeshStandardMaterial({
                    color: new THREE.Color(1, 1, 1)
                }),
                new THREE.MeshStandardMaterial({
                    color: new THREE.Color(1, 1, 1)
                }),
                new THREE.MeshStandardMaterial({
                    color: new THREE.Color(1, 1, 1)
                }),
                new THREE.MeshLambertMaterial({
                    map: new THREE.TextureLoader().load('data/images/Profile1.png')
                }),
                new THREE.MeshStandardMaterial({
                    color: new THREE.Color(1, 1, 1)
                })
            ];
            pointCloudData[0].position.set(0, -0.5, 0.5);
            pointCloudData[0].scale.set(8, 8, 1);
            pointCloudData[1].position.set(0, -0.5, 0.5);
            pointCloudData[1].scale.set(8, 8, 1);

            let bgCube1 = new THREE.Mesh(bgGeometry, bgMaterial);
            let bgCube2 = bgCube1.clone();

            bgCube1.position.set(-4.5, 0, -1);
            bgCube1.add(pointCloudData[0]);
            scene.add(bgCube1);

            bgCube2.position.set(4.5, 0, -1);
            bgCube2.add(pointCloudData[1]);
            scene.add(bgCube2);

        }

        function generatePointCloudGeometry(contourData) {
            let csD = [];
            let csR = [];
            contourData.colorscale.forEach(csv=>{
               csD.push(csv[0]);
               csR.push(csv[1]);
            });
            let colorScale = d3.scaleLinear()
                .domain(csD)
                .range(csR)
                .interpolate(d3.interpolateRgb);
            let geometry = new THREE.BufferGeometry();
            let numPoints = contourData.x.length;
            let positions = new Float32Array(numPoints * 3);
            let colors = new Float32Array(numPoints * 3);
            let xScale = d3.scaleLinear().domain(d3.extent(contourData.x)).range([-0.5, 0.5]);
            let yScale = d3.scaleLinear().domain(d3.extent(contourData.y)).range([-0.5, 0.5]);
            let zScale = d3.scaleLinear().domain(d3.extent(contourData.z)).range([0, 1]);

            for (let k = 0; k < numPoints; k += 3) {


                let u = xScale(contourData.x[k]);
                let v = yScale(contourData.y[k]);
                let x = u;
                let y = v;



                let z = zScale(contourData.z[k]);
                positions[k] = x;
                positions[k + 1] = y;
                positions[k + 2] = z;

                let intensity = (z + 0.05);
                // let intensity = 1;
                let d3c = d3.color(colorScale(z));
                let color = new THREE.Color(d3c.r/255.0, d3c.g/255.0, d3c.b/255.0);
                colors[k] = color.r * intensity;
                colors[k + 1] = color.g * intensity;
                colors[k + 2] = color.b * intensity;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.computeBoundingBox();
            return geometry;
        }

        function generatePointcloud(xyzData) {
            let geometry = generatePointCloudGeometry(xyzData);
            let material = new THREE.PointsMaterial({size: pointSize, vertexColors: THREE.VertexColors});
            return new THREE.Points(geometry, material);
        }

        //<editor-fold desc="framework tasks">

        function init() {
            let container = document.getElementById('container1');

            scene = new THREE.Scene();
            // scene.background = new THREE.Color(1, 1, 1);
            clock = new THREE.Clock();

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 10000);
            camera.position.set(0, 0, 20);
            camera.lookAt(scene.position);
            camera.updateMatrix();

            //
            //Light
            let light = new THREE.DirectionalLight(new THREE.Color(0.8, .8, .8), 1.0);
            light.position.set(0, 0, 20);
            scene.add(light);
            let aLight = new THREE.AmbientLight(new THREE.Color(0.3, 0.3, 0.3), 1.0);
            scene.add(aLight);
            //
            setupScene();

            //
            renderer = new THREE.WebGLRenderer({antialias: true});
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);

            //
            window.addEventListener('resize', onWindowResize, false);
            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 0, 0);
            controls.update();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            render();
        }

        function render() {
            camera.updateMatrixWorld();
            renderer.render(scene, camera);
        }

        //</editor-fold>

    }
</script>
<script>


</script>
</body>
</html>
